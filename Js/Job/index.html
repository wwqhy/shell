<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <!-- <script>
      var color = 'blue';
      function changeColor() {
          var anotherColor = 'red';

          function swapColors() {
              var tempColor = anotherColor;
              anotherColor = color;
              color = tempColor;
          }

          swapColors();
      }

      changeColor();
  </script> -->
  <script>
    // var a = 20;
    // var foo = {
    //     a: 10,
    //     getA: function () {
    //         return this.a;
    //     }
    // }
    // console.log(foo.getA()); // 10

    // var test = foo.getA;
    // console.log(test());  // 20

    // var a = 20;
    // function getA() {
    //     return this.a;
    // }
    // var foo = {
    //     a: 10,
    //     getA: getA
    // }
    // console.log(foo.getA());  // 10
    // 类数组对象
    // function exam(a, b, c, d, e) {

    //     // 先看看函数的自带属性 arguments 什么是样子的
    //     console.log(arguments);

    //     // 使用call/apply将arguments转换为数组, 返回结果为数组，arguments自身不会改变
    //     var arg = [].slice.call(arguments);

    //     console.log(arg);
    // }

    // exam(2, 8, 9, 10, 3);
    // 也常常使用该方法将DOM中的nodelist转换为数组
    // [].slice.call( document.getElementsByTagName('li') );
  </script>
  <script>
//   function Person(name, age) {

//     // 这里的this指向了谁?
//     this.name = name;
//     this.age = age; 
//     console.log(this)  
//     }

//     Person.prototype.getName = function() {

//     // 这里的this又指向了谁？
//     console.log(this)
//     return this.name;
// }

//     // 上面的2个this，是同一个吗，他们是否指向了原型对象？
//     console.log(typeof (new Person))
//     var p1 = new Person('Nick', 20);
//     p1.getName();
  </script>  
  <script>
  //   function add() {
  //     // 第一次执行时，定义一个数组专门用来存储所有的参数
  //     var args = [].slice.call(arguments);

  //     var fn = function () {
  //       var newArgs = [].slice.call(arguments)
  //       // return add.apply(null, [...args, ...newArgs])
  //       return add(...[...args, ...newArgs])
  //     }
  //     fn.valueOf = function () {
  //       return args.reduce(function (a, b) {
  //         return a + b
  //       })
  //     }
  //     return fn
  //   } 
  // console.log('123', add(1,2)(3)(4))
  // console.log(add(1,2) + 3)
  </script>
  <script>
    // 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别
    // var Person = function(name, age) {
    //     this.name = name;
    //     this.age = age;
    //     this.getName = function() {
    //         return this.name;
    //     }
    // }
    // // 将构造函数以参数形式传入
    // function New(func) {

    //     // 声明一个中间对象，该对象为最终返回的实例
    //     var res = {};
    //     if (func.prototype !== null) {

    //         // 将实例的原型指向构造函数的原型
    //         res.__proto__ = func.prototype;
    //     }

    //     // ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象
    //     var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));

    //     // 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象
    //     if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
    //         return ret;
    //     }

    //     // 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象
    //     return res;
    // }
    // console.log(Person.prototype)
    // // 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res
    // var p1 = New(Person, 'tom', 20);
    // console.log('p1', p1)
    // console.log(p1.getName());
    // var p2 = new Person('jake', 20)
    // console.log('p2', p2)
    // // 当然，这里也可以判断出实例的类型了
    // console.log(p1 instanceof Person); // true
    // console.log(p2 instanceof Person); // 
  </script>
  <script>
    function Person(name, age) {
        this.name = name;
        this.age = age;
    }

    Person.prototype.getName = function() {
        return this.name;
    }

    function childPerson () {
    }
    childPerson.prototype = new Person()
    console.log(childPerson.prototype)
    var res = new childPerson()
    console.log(res)
  </script>
</body>
</html>